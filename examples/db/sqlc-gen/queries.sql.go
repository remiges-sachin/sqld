// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEmployee = `-- name: GetEmployee :one
SELECT id, first_name, last_name, email, phone, hire_date, salary, department, position, is_active, created_at, updated_at FROM employees WHERE id = $1
`

func (q *Queries) GetEmployee(ctx context.Context, id int64) (Employee, error) {
	row := q.db.QueryRow(ctx, getEmployee, id)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.HireDate,
		&i.Salary,
		&i.Department,
		&i.Position,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const uCCList = `-- name: UCCList :many
SELECT
    u.ucc_id,
    u.client_code,
    u.member_code,
    ts.tax_name AS tax_status,
    crm.entity_key AS holding_nature,
    ucc_status.entity_key AS ucc_status,
    u.is_client_physical,
    u.is_client_demat,
    u.parent_client_code,
    COALESCE(
        CASE
            WHEN pd.first_name IS NOT NULL THEN CONCAT(pd.first_name, ' ', pd.middle_name, ' ', pd.last_name)
            WHEN nid.org_name IS NOT NULL THEN nid.org_name
            ELSE ''
        END, 
    '') AS primary_holder_name
FROM
    ucc u
LEFT JOIN
    holder h ON u.ucc_id = h.ref_id 
    AND h.holder_rank = (
        SELECT id 
        FROM common_reference_master 
        WHERE entity = 'UCC_HOLDER_RANK' 
          AND entity_key = 'FIRST'
    )
    AND h.deleted_at IS NULL 
    AND h.deleted_by IS NULL
LEFT JOIN
    person_detail pd ON pd.ref_id = h.id AND h.ref_id = u.ucc_id AND pd.entity_type = 'HOLDER'
LEFT JOIN 
    non_individual_detail nid ON nid.ref_id = h.id AND nid.entity_type = 'HOLDER'
LEFT JOIN
    common_reference_master AS crm ON u.holding_nature = crm.id AND crm.entity = 'UCC_HOLDING_TYPE'
LEFT JOIN
    common_reference_master AS ucc_status ON u.ucc_status = ucc_status.id AND ucc_status.entity = 'UCC_ACC_STATUS'
LEFT JOIN
    tax_status_master AS ts ON u.tax_status = ts.id
WHERE
    -- For integer params, NULL means no filter:
    ($1::bigint IS NULL OR u.ucc_status = $1::bigint) AND
    ($2::bigint IS NULL OR u.tax_status = $2::bigint) AND
    ($3::bigint IS NULL OR u.holding_nature = $3::bigint) AND

    -- For boolean params, NULL means no filter:
    ($4::boolean IS NULL OR u.is_client_physical = $4::boolean) AND
    ($5::boolean IS NULL OR u.is_client_demat = $5::boolean) AND
    NOT (u.is_client_physical = false AND u.is_client_demat = false) AND

    u.deleted_at IS NULL AND u.deleted_by IS NULL AND

    -- For text params, NULL or '' means no filter:
    ($6::text IS NULL OR $6::text = '' OR u.client_code ILIKE $6::text || '%') AND
    ($7::text IS NULL OR $7::text = '' OR u.member_code ILIKE $7::text || '%') AND
    ($8::text IS NULL OR $8::text = '' OR u.parent_client_code ILIKE $8::text || '%') AND
    (
        $9::text IS NULL
        OR $9::text = ''
        OR (
            CONCAT_WS(' ', 
                u.client_code,  
                u.member_code,
                u.parent_client_code,
                ts.tax_name, 
                crm.entity_key,
                COALESCE(
                    pd.first_name || ' ' || pd.middle_name || ' ' || pd.last_name,
                    nid.org_name
                ),
                ucc_status.entity_key,
                CASE WHEN u.is_client_physical THEN 'true' ELSE 'false' END,
                CASE WHEN u.is_client_demat THEN 'true' ELSE 'false' END,
                COALESCE(pd.first_name, nid.org_name)
            ) ILIKE '%' || $9::text || '%'
        )
    )
ORDER BY
    CASE 
        WHEN $10 = 'ucc_id' AND upper($11) = 'A' THEN u.ucc_id
    END ASC,
    CASE 
        WHEN $10 = 'ucc_id' AND upper($11) = 'D' THEN u.ucc_id
    END DESC,
    CASE
        WHEN $10 = 'client_code' AND upper($11) = 'A' THEN u.client_code
    END ASC,
    CASE 
        WHEN $10 = 'client_code' AND upper($11) = 'D' THEN u.client_code
    END DESC,
    CASE
        WHEN $10 = 'member_code' AND upper($11) = 'A' THEN u.member_code
    END ASC,
    CASE 
        WHEN $10 = 'member_code' AND upper($11) = 'D' THEN u.member_code
    END DESC,
    CASE
        WHEN $10 = 'tax_status' AND upper($11) = 'A' THEN ts.tax_name
    END ASC,
    CASE 
        WHEN $10 = 'tax_status' AND upper($11) = 'D' THEN ts.tax_name
    END DESC,
    CASE
        WHEN $10 = 'primary_holder_name' AND upper($11) = 'A' THEN COALESCE(pd.first_name, nid.org_name)
    END ASC,
    CASE 
        WHEN $10 = 'primary_holder_name' AND upper($11) = 'D' THEN COALESCE(pd.first_name, nid.org_name)
    END DESC
OFFSET $12::int
LIMIT $13::int
`

type UCCListParams struct {
	UccStatus        pgtype.Int8  `json:"ucc_status" db:"ucc_status"`
	TaxStatus        pgtype.Int8  `json:"tax_status" db:"tax_status"`
	HoldingNature    pgtype.Int8  `json:"holding_nature" db:"holding_nature"`
	IsClientPhysical pgtype.Bool  `json:"is_client_physical" db:"is_client_physical"`
	IsClientDemat    pgtype.Bool  `json:"is_client_demat" db:"is_client_demat"`
	ClientCode       pgtype.Text  `json:"client_code" db:"client_code"`
	MemberCode       pgtype.Text  `json:"member_code" db:"member_code"`
	ParentClientCode pgtype.Text  `json:"parent_client_code" db:"parent_client_code"`
	Search           pgtype.Text  `json:"search" db:"search"`
	SortBy           interface{}  `json:"sort_by" db:"sort_by"`
	SortOrder        interface{}  `json:"sort_order" db:"sort_order"`
	Offset           pgtype.Int4  `json:"offset" db:"offset"`
	Limit            pgtype.Int4  `json:"limit" db:"limit"`
}

type UCCListRow struct {
	UccID             int64       `json:"ucc_id" db:"ucc_id"`
	ClientCode        pgtype.Text `json:"client_code" db:"client_code"`
	MemberCode        pgtype.Text `json:"member_code" db:"member_code"`
	TaxStatus         pgtype.Text `json:"tax_status" db:"tax_status"`
	HoldingNature     pgtype.Text `json:"holding_nature" db:"holding_nature"`
	UccStatus         pgtype.Text `json:"ucc_status" db:"ucc_status"`
	IsClientPhysical  bool        `json:"is_client_physical" db:"is_client_physical"`
	IsClientDemat     bool        `json:"is_client_demat" db:"is_client_demat"`
	ParentClientCode  pgtype.Text `json:"parent_client_code" db:"parent_client_code"`
	PrimaryHolderName interface{} `json:"primary_holder_name" db:"primary_holder_name"`
}

func (q *Queries) UCCList(ctx context.Context, arg UCCListParams) ([]UCCListRow, error) {
	rows, err := q.db.Query(ctx, uCCList,
		arg.UccStatus,
		arg.TaxStatus,
		arg.HoldingNature,
		arg.IsClientPhysical,
		arg.IsClientDemat,
		arg.ClientCode,
		arg.MemberCode,
		arg.ParentClientCode,
		arg.Search,
		arg.SortBy,
		arg.SortOrder,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UCCListRow
	for rows.Next() {
		var i UCCListRow
		if err := rows.Scan(
			&i.UccID,
			&i.ClientCode,
			&i.MemberCode,
			&i.TaxStatus,
			&i.HoldingNature,
			&i.UccStatus,
			&i.IsClientPhysical,
			&i.IsClientDemat,
			&i.ParentClientCode,
			&i.PrimaryHolderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
